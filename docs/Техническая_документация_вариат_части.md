# Руководство по исследованию и созданию Мультисервисного веб-портала на Flask

**Версия:** 1.0
**Авторы:** [Мукабенов Дмитрий]

---

## 1. Введение

Данное руководство представляет собой комплексное описание процесса исследования, проектирования и разработки технологии "Мультисервисный веб-портал", реализованной с использованием языка программирования Python и микрофреймворка Flask. Проект был выполнен в рамках проектной (учебной) практики и тесно связан с более масштабной исследовательской работой по теме «Применение искусственного интеллекта в профессиональном обучении», а также с проектом по дисциплине «Проектная деятельность» – «Перестройка бизнес-процессов на базе мультиагентных систем с GPT».

Создание мультисервисного веб-портала было выбрано в качестве практической реализации технологии не случайно. В современном цифровом мире потребность в удобных, централизованных и легкодоступных онлайн-инструментах постоянно растет. Наш портал призван предоставить пользователям именно такой набор утилит, охватывающих различные повседневные и рабочие задачи, от простого ведения списка дел до более специализированных функций, таких как сокращение URL-адресов или генерация данных.

В ходе работы над проектом особое внимание уделялось не только технической реализации функциональности, но и качеству пользовательского опыта, понятности интерфейсов и доступности документации по использованию API для потенциальных разработчиков. Я стремился создать продукт, который был бы полезен как конечным пользователям, так и тем, кто захочет интегрировать наши сервисы в свои системы.

### 1.1. Цель документа

Основной целью настоящего документа является предоставление исчерпывающего и пошагового руководства, освещающего все ключевые этапы создания описанной технологии. Я ставил перед собой задачу не просто зафиксировать результат, но и поделиться опытом, который может быть полезен другим начинающим разработчикам, сталкивающимся с аналогичными задачами.

Таким образом, документ преследует следующие цели:

*   **Систематизировать и представить** последовательность действий, предпринятых в ходе исследования предметной области, выбора технологического стека и непосредственной разработки веб-портала.
*   **Описать архитектурные решения** и ключевые компоненты созданной системы, объяснив логику их выбора и взаимодействия.
*   **Предоставить детальное техническое руководство** по созданию подобного веб-портала с нуля, включая настройку окружения, реализацию бэкенда на Flask, создание API-эндпоинтов, разработку фронтенда (HTML, CSS, JavaScript) и интеграцию интерактивных пользовательских интерфейсов.
*   **Продемонстрировать практическое применение** теоретических знаний в области веб-разработки, создания RESTful API и организации клиент-серверного взаимодействия.
*   **Служить образовательным материалом** для тех, кто только начинает свой путь в веб-разработке на Python и Flask, предлагая понятные инструкции и наглядные примеры кода.

### 1.2. Для кого это руководство?

Данное руководство ориентировано на достаточно широкую аудиторию, однако в первую очередь оно будет полезно следующим категориям читателей:

*   **Начинающие веб-разработчики:** Студенты IT-специальностей, а также все, кто делает первые шаги в создании веб-приложений и API, особенно с использованием Python и Flask. Руководство написано с учетом того, что читатель может не обладать глубокими предварительными знаниями.
*   **Студенты, выполняющие учебные проекты:** Материал может служить примером и источником вдохновения для выполнения схожих заданий в рамках курсовых работ, практик или дипломных проектов.
*   **Разработчики, желающие освоить Flask:** Те, кто уже имеет некоторый опыт в программировании, но хочет быстро освоить основы создания веб-приложений на данном микрофреймворке.
*   **Преподаватели и менторы:** Руководство может быть использовано в качестве дополнительного учебного материала при объяснении принципов веб-разработки и создания API.
*   **Участники проекта (если применимо):** Как справочный документ, фиксирующий ключевые этапы разработки и принятые решения.

Я постарался изложить материал максимально доступно, сопровождая теоретические выкладки практическими примерами кода и иллюстрациями, чтобы сделать процесс изучения технологии увлекательным и продуктивным.

### 1.3. Обзор технологии

Разработанный "Мультисервисный веб-портал" представляет собой веб-приложение, построенное на базе микрофреймворка Flask. Его архитектура следует классической клиент-серверной модели.

**Ключевые технологические аспекты и функциональные компоненты:**

*   **Бэкенд (Серверная часть):**
    *   Реализован на **Python 3** с использованием **Flask**.
    *   Отвечает за обработку HTTP-запросов, бизнес-логику сервисов и взаимодействие с (временно внутрисерверными) хранилищами данных.
    *   Предоставляет **RESTful API** для каждого из реализованных сервисов, позволяя сторонним приложениям и клиентскому JavaScript взаимодействовать с функциональностью портала.
*   **Фронтенд (Клиентская часть):**
    *   Построен на стандартных веб-технологиях: **HTML** для структуры страниц, **CSS** для стилизации и **JavaScript** (ванильный) для обеспечения интерактивности пользовательских интерфейсов.
    *   Использует шаблонизатор **Jinja2** (интегрированный во Flask) для динамической генерации HTML-страниц на основе данных с сервера.
*   **Реализованные сервисы:**
    1.  **Список задач (To-Do List):** Интерактивное управление личными задачами (создание, просмотр, обновление, удаление) с соответствующим API.
    2.  **Сокращатель URL-адресов:** Преобразование длинных URL в короткие с возможностью редиректа и API для автоматизации.
    3.  **Цитаты дня и Факты:** Получение случайных или конкретных по ID цитат/фактов; API для добавления новых записей (с Basic Auth).
    4.  **Каталог книг и фильмов:** Ведение личной медиатеки с добавлением, просмотром и фильтрацией записей; API для управления каталогом.
    5.  **Простой онлайн-калькулятор:** Выполнение базовых арифметических операций через интерактивный UI, имитирующий физический калькулятор, и через API.
    6.  **Генератор случайных данных:** Создание случайных чисел в заданном диапазоне и паролей с настраиваемыми параметрами, доступное через UI и API.
*   **Пользовательский интерфейс (UI):**
    *   Каждый сервис имеет свою выделенную веб-страницу, которая сочетает в себе подробную документацию по API (для разработчиков) и интерактивный блок (для непосредственного использования функциональности пользователями).
    *   Общая навигация по сайту осуществляется через единый хедер и страницу "Сервисы", представляющую доступные инструменты в виде виджетов.
    *   Дизайн стремится к чистоте, интуитивной понятности и удобству использования.

В следующих разделах данного руководства я подробно рассмотрел процесс исследования, который предшествовал разработке, детально опишем шаги по проектированию и созданию каждого компонента этой технологии, сопровождая объяснения примерами кода и иллюстрациями.

## 2. Исследование предметной области

Прежде чем приступить к непосредственной разработке "Мультисервисного веб-портала", был проведен этап исследования предметной области. Этот этап является критически важным, поскольку позволяет четко определить цели проекта, понять потребности потенциальных пользователей, изучить существующие аналоги и выбрать наиболее подходящий технологический стек для реализации поставленных задач.

### 2.1. Определение проблемы и постановка задачи

На начальном этапе была сформулирована основная проблема, которую призван решить разрабатываемый портал. В современном информационном пространстве существует множество разрозненных онлайн-инструментов и утилит, предназначенных для выполнения различных повседневных или специфических задач (например, ведение списков дел, сокращение URL-адресов, генерация случайных данных и т.д.). Пользователям часто приходится переключаться между несколькими сайтами или приложениями, что не всегда удобно и эффективно. Кроме того, разработчикам, нуждающимся в интеграции подобных функций в свои проекты, не всегда легко найти простые, хорошо документированные и легковесные API.

**Постановка задачи** в рамках проекта заключалась в создании единой, централизованной веб-платформы, которая бы:
*   Объединяла набор востребованных мини-сервисов под общей оболочкой.
*   Предоставляла удобный графический пользовательский интерфейс (GUI) для прямого использования этих сервисов конечными пользователями.
*   Предлагала разработчикам понятный и простой в использовании RESTful API для каждого сервиса, позволяющий легко интегрировать их функциональность в сторонние приложения.
*   Служила практическим примером реализации веб-приложения на Python с использованием микрофреймворка Flask, что было одной из целей учебной практики.

#### 2.1.1. Анализ существующих решений (если применимо)

В ходе исследования были рассмотрены существующие на рынке решения, предлагающие отдельные или схожие по функциональности сервисы. Например:

*   **Для управления задачами:** Существует множество как крупных платформ (Trello, Asana, Jira – хотя они ориентированы на более сложные процессы управления проектами), так и более простых To-Do приложений (Todoist, Microsoft To Do, Google Tasks). Основное отличие нашего подхода – интеграция в мультисервисную платформу и предоставление простого API.
*   **Для сокращения URL:** Сервисы типа Bitly, TinyURL, Cutt.ly предлагают схожий функционал. Наш проект ставил целью создать легковесную альтернативу с открытым API, которую можно было бы развернуть и использовать локально или в рамках собственных проектов.
*   **Для цитат или случайных данных:** Множество сайтов предлагают подобный контент, но часто без удобного API или с избыточной функциональностью. Задача была в создании простого, кастомизируемого (через добавление своих цитат) и API-доступного сервиса.
*   **Для калькуляторов и генераторов:** Онлайн-калькуляторы и генераторы широко распространены, но часто перегружены рекламой или сложным интерфейсом. Цель – создать чистый, быстрый инструмент с возможностью API-доступа.

Анализ показал, что хотя отдельные сервисы хорошо представлены, удобной **интегрированной платформы**, предлагающей набор таких разноплановых утилит с простым UI и одновременно легковесным API, ориентированным на разработчиков-новичков или для быстрого прототипирования, не так много. Это и стало одной из ниш, которую стремился занять наш проект.

#### 2.1.2. Формулирование требований к создаваемой технологии

На основе анализа проблемы и существующих решений были сформулированы следующие ключевые требования к "Мультисервисному веб-порталу":

*   **Функциональные требования (к каждому сервису):**
    *   **Список задач:** CRUD-операции (создание, чтение, обновление, удаление задач), отметка о выполнении.
    *   **Сокращатель URL:** Прием длинного URL, генерация уникального короткого кода, редирект по короткому коду.
    *   **Цитаты дня:** Выдача случайной цитаты, выдача цитаты по ID, возможность добавления новых цитат (с аутентификацией).
    *   **Каталог книг/фильмов:** Добавление записей (тип, название, автор/режиссер, год, жанр), просмотр всех записей, просмотр по ID, фильтрация.
    *   **Калькулятор:** Выполнение базовых арифметических операций (+, -, \*, /).
    *   **Генератор случайных данных:** Генерация чисел в диапазоне, генерация паролей с параметрами длины и использования символов.
*   **Требования к API:**
    *   Для каждого сервиса должен быть предоставлен RESTful API.
    *   API должен быть хорошо документирован на страницах соответствующих сервисов.
    *   Использование стандартных HTTP-методов (GET, POST, PUT, DELETE).
    *   Обмен данными в формате JSON.
    *   Корректная обработка ошибок и возврат соответствующих HTTP-статус кодов.
*   **Требования к пользовательскому интерфейсу (UI):**
    *   Интуитивно понятный и простой в использовании интерфейс для каждого сервиса.
    *   Возможность взаимодействия с основной функциональностью сервисов прямо на веб-странице.
    *   Единый стиль оформления для всех страниц портала.
    *   Адаптивность макета для корректного отображения на различных устройствах (базовая).
*   **Нефункциональные требования:**
    *   **Простота развертывания и поддержки** (в рамках учебного проекта).
    *   **Расширяемость:** Архитектура должна позволять относительно легко добавлять новые сервисы в будущем.
    *   **Надежность:** Корректная обработка пользовательского ввода и ошибок.
    *   **Безопасность:** Базовая аутентификация для операций, изменяющих данные (например, добавление цитат).

### 2.2. Выбор стека технологий

Выбор технологического стека основывался на требованиях проекта, учебных целях практики и доступности инструментов для начинающих разработчиков.

#### 2.2.1. Обоснование выбора Python и Flask

*   **Python:** Был выбран в качестве основного языка для серверной разработки благодаря его простоте синтаксиса, богатой стандартной библиотеке и огромному количеству сторонних пакетов, что значительно ускоряет разработку. Python также является популярным языком для веб-разработки и анализа данных, что соответствует более широкому контексту проекта, связанного с ИИ. Его низкий порог входа делает его отличным выбором для учебных проектов.
*   **Flask:** В качестве веб-фреймворка был выбран Flask. Это микрофреймворк, что означает его минималистичность и гибкость. Основные причины выбора:
    *   **Простота освоения:** Flask имеет очень понятную структуру и небольшое ядро, что позволяет быстро начать разработку.
    *   **Гибкость:** Не навязывает строгую структуру проекта или конкретные инструменты (ORM, шаблонизаторы и т.д.), позволяя разработчику выбирать компоненты по своему усмотрению. Это хорошо для понимания основ веб-разработки.
    *   **Расширяемость:** Несмотря на свою "микро"-природу, Flask легко расширяется с помощью множества доступных расширений для решения практически любых задач (аутентификация, работа с базами данных, и т.д.).
    *   **Подходит для API:** Flask отлично подходит для создания RESTful API благодаря своей простоте в обработке маршрутов и HTTP-запросов.
    *   **Учебные цели:** Задание по практике прямо рекомендовало ознакомиться с реализацией RESTful API с помощью Python и Flask на основе предоставленного теоретического материала, что сделало этот выбор очевидным.

#### 2.2.2. Обзор HTML, CSS, JavaScript для фронтенда

Для создания клиентской части веб-портала был использован классический набор фронтенд-технологий:

*   **HTML (HyperText Markup Language):** Использовался для определения структуры и семантической разметки веб-страниц. Шаблонизатор Jinja2, интегрированный во Flask, применялся для динамической генерации HTML на основе данных с сервера, а также для создания переиспользуемых компонентов макета (наследование шаблонов, блоки).
*   **CSS (Cascading Style Sheets):** Применялся для визуального оформления и стилизации HTML-элементов. Был создан единый файл стилей (`style.css`), содержащий как общие стили для всего сайта (макет, навигация, футер), так и специфические стили для каждого интерактивного сервиса, чтобы обеспечить их уникальный и удобный вид.
*   **JavaScript (Vanilla JS):** Использовался для добавления интерактивности на страницы сервисов. В частности, JavaScript отвечает за:
    *   Отправку асинхронных запросов (AJAX, с использованием Fetch API) к API-эндпоинтам бэкенда без перезагрузки страницы.
    *   Динамическое обновление содержимого страницы на основе ответов от сервера (например, отображение списка задач, результатов вычислений, сгенерированных данных).
    *   Обработку событий от пользовательских элементов управления (кнопки, формы).
    *   Валидацию данных на стороне клиента перед отправкой на сервер (базовая).

Выбор "ванильного" JavaScript (без использования фронтенд-фреймворков типа React, Vue или Angular) был сделан для концентрации на фундаментальных принципах работы с DOM и AJAX, что более соответствует уровню начинающего разработчика и учебным целям практики.

### 2.3. Изучение ключевых концепций

Для успешной реализации проекта потребовалось изучение и понимание ряда ключевых концепций веб-разработки и создания API:

*   **REST (Representational State Transfer):** Изучение принципов построения RESTful API, таких как использование стандартных HTTP-методов для операций с ресурсами, именование URL-путей для представления ресурсов, stateless-взаимодействие. Теоретический материал, предоставленный в рамках задания практики (статья Луиса Рея "Implementing a RESTful Web API with Python & Flask"), послужил отличной отправной точкой.
*   **HTTP-методы:** Понимание назначения и правильного применения основных HTTP-методов:
    *   `GET`: для запроса данных.
    *   `POST`: для создания новых ресурсов.
    *   `PUT`: для полного обновления существующих ресурсов.
    *   `DELETE`: для удаления ресурсов.
    *   (Также были рассмотрены, но не использовались активно `PATCH` для частичного обновления).
*   **HTTP-статус коды:** Изучение стандартных кодов ответа HTTP (200 OK, 201 Created, 400 Bad Request, 404 Not Found, 401 Unauthorized, 500 Internal Server Error и др.) для корректной обратной связи от API.
*   **JSON (JavaScript Object Notation):** Освоение формата JSON как основного способа обмена данными между клиентом и сервером в RESTful API. Понимание структуры JSON, методов сериализации (Python dict -> JSON string) и десериализации (JSON string -> Python dict).
*   **Маршрутизация во Flask (`@app.route`)**: Понимание того, как Flask связывает URL-адреса и HTTP-методы с конкретными функциями-обработчиками Python.
*   **Обработка запросов во Flask (объект `request`):** Изучение способов получения данных из входящего HTTP-запроса: параметры URL (query parameters), данные из тела запроса (JSON, данные форм), заголовки.
*   **Формирование ответов во Flask (функция `jsonify`, объект `Response`):** Научились создавать корректные HTTP-ответы, включая JSON-данные и установку соответствующих статус-кодов и заголовков.
*   **Шаблонизация с Jinja2:** Освоение синтаксиса Jinja2 для создания динамических HTML-страниц, наследования шаблонов, использования переменных и управляющих конструкций (циклы, условия).
*   **Basic Authentication:** Изучение простого механизма аутентификации для защиты определенных API-эндпоинтов.

Это исследование позволило заложить прочный теоретический и практический фундамент для последующего проектирования и разработки "Мультисервисного веб-портала".

## 3. Проектирование технологии

После этапа исследования предметной области и определения ключевых требований начался этап проектирования "Мультисервисного веб-портала". На этой стадии были заложены основы архитектуры системы, определена структура проекта, детально спроектированы API-эндпоинты для каждого сервиса и сформирована общая концепция пользовательского интерфейса. Грамотное проектирование является залогом успешной и предсказуемой разработки, позволяя минимизировать риски и упростить дальнейшую поддержку и расширение функциональности.

### 3.1. Общая архитектура системы

Для "Мультисервисного веб-портала" была выбрана классическая **трехзвенная архитектура**, характерная для большинства веб-приложений. Эта архитектура подразумевает разделение системы на следующие логические компоненты:

1.  **Клиентская часть (Frontend / Presentation Tier):**
    *   Реализована с использованием стандартных веб-технологий: HTML (структура), CSS (стилизация) и JavaScript (интерактивность).
    *   Отвечает за отображение информации пользователю и взаимодействие с ним через веб-браузер.
    *   Именно на этой стороне происходит формирование запросов к серверу (API-эндпоинтам) и динамическое обновление страниц на основе полученных ответов.
    *   HTML-страницы генерируются на стороне сервера с помощью шаблонизатора Jinja2, но клиентский JavaScript обеспечивает дальнейшую интерактивность без полной перезагрузки страниц.

2.  **Серверная часть (Backend / Application Tier):**
    *   Разработана на языке Python с использованием микрофреймворка Flask.
    *   Является "мозгом" приложения. Здесь происходит обработка входящих HTTP-запросов от клиента.
    *   Реализует всю бизнес-логику каждого из шести сервисов (список задач, сокращатель URL и т.д.).
    *   Определяет и обрабатывает RESTful API-эндпоинты, через которые клиентская часть или сторонние приложения могут взаимодействовать с сервисами.
    *   Управляет состоянием приложения и взаимодействием с хранилищем данных (в текущей версии – внутрисерверные структуры данных).

3.  **Уровень данных (Data Tier):**
    *   В текущей реализации проекта этот уровень представлен глобальными переменными Python (списками и словарями), хранящимися в оперативной памяти сервера `app.py`. Это решение было принято для упрощения на начальном этапе разработки и в рамках учебных целей.
    *   В будущем **(критическое TODO)** этот уровень должен быть заменен на полноценную систему управления базами данных (например, SQLite для простоты или PostgreSQL/MySQL для более серьезных нагрузок). Это обеспечит постоянное хранение данных, их целостность и возможность более сложных запросов.

**Взаимодействие компонентов:** Пользователь взаимодействует с клиентской частью через браузер. JavaScript на клиенте отправляет асинхронные запросы (Fetch API) на соответствующие API-эндпоинты серверной части. Серверная часть (Flask) обрабатывает эти запросы, выполняет необходимую логику, при необходимости обращается к данным и возвращает ответ (обычно в формате JSON) обратно на клиент, где JavaScript обновляет пользовательский интерфейс.

**(Иллюстрация 1: Вставить здесь диаграмму общей архитектуры)**
*   *Описание для иллюстрации:* "На диаграмме можно схематично представить взаимодействие Клиента (веб-браузер с HTML/CSS/JS), Сервера приложений (Python/Flask с API и бизнес-логикой) и Уровня данных (пока в памяти, в будущем – БД)."

    ![Общая архитектура Мультисервисного веб-портала](путь/к/вашей/диаграмме_архитектуры.png "Схема взаимодействия компонентов портала")
    *(Замените `путь/к/вашей/диаграмме_архитектуры.png` на реальный путь. Диаграмма может быть простой: блок "Браузер пользователя", стрелка к блоку "Flask-сервер (app.py)", от него стрелка к блоку "Хранилище данных (в памяти)", и обратные стрелки.)*

### 3.2. Структура проекта (файловая структура)

Для организации кода и ресурсов была принята стандартная для Flask-приложений и интуитивно понятная файловая структура:
/multi_service_site/ # Корневая папка проекта
├── app.py # Основной файл приложения Flask (бэкенд, API, маршруты)
├── static/ # Папка для статических файлов (доступных клиенту напрямую)
│ ├── css/
│ │ └── style.css # Главный файл стилей
│ └── images/
│ └── home-button.png # Иконка для сайта (и другие изображения)
│ └── ... (другие изображения для UI, логотипы и т.д.)
├── templates/ # Папка для HTML-шаблонов Jinja2
│ ├── layout.html # Базовый макет (общий для всех страниц)
│ ├── index.html # Шаблон главной страницы
│ ├── services.html # Шаблон страницы со списком всех сервисов
│ ├── service_todo.html # Шаблон для сервиса "Список Задач"
│ ├── service_shortener.html # Шаблон для сервиса "Сокращатель URL"
│ ├── service_quote.html # Шаблон для сервиса "Цитаты дня"
│ ├── service_catalog.html # Шаблон для сервиса "Каталог"
│ ├── service_calculator.html # Шаблон для сервиса "Калькулятор"
│ ├── service_random.html # Шаблон для сервиса "Генератор данных"
│ └── service_details.html # (Опционально, если остался как базовый для только документации)
├── README.md # Файл с описанием проекта и инструкциями по запуску
└── .gitignore # Файл для исключения ненужных файлов из Git


**Пояснения к структуре:**

*   **`app.py`**: Содержит всю логику на Python, включая определение маршрутов Flask, обработчики API-эндпоинтов и бизнес-логику сервисов. Здесь же (временно) находятся переменные для хранения данных.
*   **`static/`**: Эта папка используется Flask для обслуживания статических файлов, таких как таблицы стилей CSS, изображения, и клиентские JavaScript файлы (если бы они были вынесены отдельно). Пути к файлам в этой папке генерируются в шаблонах с помощью `url_for('static', filename='...')`.
*   **`templates/`**: Здесь хранятся все HTML-шаблоны, которые обрабатываются шаблонизатором Jinja2. Flask автоматически ищет шаблоны в этой директории.
*   **`README.md`**: Важный файл для любого проекта, содержащий основную информацию и инструкции.
*   `.gitignore`**: Этот файл является хорошей практикой для любого Python-проекта, управляемого с помощью Git, для чистоты репозитория.

Такая структура является достаточно стандартной, что облегчает понимание проекта другими разработчиками и его дальнейшую поддержку.

**(Иллюстрация 2: Можно вставить здесь упрощенную диаграмму файловой структуры)**
*   *Описание для иллюстрации:* "Схематическое представление основных директорий и файлов проекта, показывающее их иерархию."

    ![Файловая структура проекта](путь/к/диаграмме_структуры_проекта.png "Основные папки и файлы проекта")

### 3.3. Проектирование API-эндпоинтов (для каждого сервиса)

Ключевой частью проекта является предоставление RESTful API для каждого сервиса. При проектировании эндпоинтов я старался следовать общепринятым конвенциям и принципам REST. Для всех API-эндпоинтов данные передаются и принимаются в формате JSON.

Ниже приведено описание эндпоинтов для каждого реализованного сервиса:

**(Иллюстрация 3: Вместо длинных таблиц ниже, можно начать с общей схемы проектирования API, например, с типичным набором эндпоинтов для CRUD-операций на примере одного ресурса. Это будет визуальным введением перед детализацией каждого сервиса.)**

*   *Описание для иллюстрации:* "Общий подход к проектированию RESTful API: использование HTTP-методов для стандартных операций с ресурсами."
    *   `GET /resource` (получить список)
    *   `POST /resource` (создать новый)
    *   `GET /resource/{id}` (получить по ID)
    *   `PUT /resource/{id}` (обновить по ID)
    *   `DELETE /resource/{id}` (удалить по ID)

    ![Общая схема REST API](путь/к/вашей/схеме_rest_api.png "Принципы RESTful API")

**3.3.1. Сервис "Список Задач (To-Do List)"**
| Метод | Путь             | Описание                                                     | Тело запроса (JSON)                | Пример ответа (JSON)                                 |
|-------|------------------|--------------------------------------------------------------|------------------------------------|------------------------------------------------------|
| POST  | `/api/tasks`     | Создать новую задачу                                         | `{"text": "Описание задачи"}`        | `{"message": "...", "task": {"id": ..., "text": ..., "done": false}}` |
| GET   | `/api/tasks`     | Получить список всех задач                                   | -                                  | `{"count": ..., "tasks": [...]}`                      |
| GET   | `/api/tasks/<id>`| Получить задачу по ID                                        | -                                  | `{"task": {"id": ..., "text": ..., "done": ...}}`     |
| PUT   | `/api/tasks/<id>`| Обновить задачу (текст и/или статус выполнения)            | `{"text": "...", "done": true/false}` | `{"message": "...", "task": {...}}`                     |
| DELETE| `/api/tasks/<id>`| Удалить задачу по ID                                         | -                                  | `{"message": "..."}`                                  |

**3.3.2. Сервис "Сокращатель URL-адресов"**
| Метод | Путь             | Описание                                           | Тело запроса (JSON)           | Пример ответа (JSON)                                      |
|-------|------------------|----------------------------------------------------|-------------------------------|-----------------------------------------------------------|
| POST  | `/api/shorten`   | Сократить длинный URL                                | `{"long_url": "http://..."}`   | `{"message": "...", "short_url": "...", "original_url": "..."}` |
| GET   | `/s/<short_code>`| Редирект по короткому коду на оригинальный URL      | -                             | (Редирект 302)                                             |

**3.3.3. Сервис "Цитаты дня и Факты"**
| Метод | Путь               | Описание                                                      | Тело запроса (JSON)              | Пример ответа (JSON)                           |
|-------|--------------------|---------------------------------------------------------------|----------------------------------|------------------------------------------------|
| GET   | `/api/quotes/random`| Получить случайную цитату/факт                                 | -                                | `{"id": ..., "text": ..., "author": ...}`         |
| GET   | `/api/quotes/<id>` | Получить цитату/факт по ID                                   | -                                | `{"id": ..., "text": ..., "author": ...}`         |
| POST  | `/api/quotes`      | Добавить новую цитату (требуется Basic Authentication)         | `{"text": "...", "author": "..."}` | `{"message": "...", "quote": {...}}`           |

**3.3.4. Сервис "Каталог книг и фильмов"**
| Метод | Путь             | Описание                                                      | Тело запроса (JSON)                                   | Пример ответа (JSON)                         |
|-------|------------------|---------------------------------------------------------------|-------------------------------------------------------|----------------------------------------------|
| POST  | `/api/catalog`   | Добавить новый элемент (книгу или фильм)                     | `{"type": "book/movie", "title": ..., "author/director": ..., "year": ..., "genre": ...}` | `{"message": "...", "item": {...}}`            |
| GET   | `/api/catalog`   | Получить список всех элементов (поддерживает фильтрацию)      | -                                                     | `[{"id": ..., "title": ...}, ...]`            |
| GET   | `/api/catalog/<id>`| Получить элемент каталога по ID                               | -                                                     | `{"id": ..., "title": ...}`                   |

**3.3.5. Сервис "Простой онлайн-калькулятор"**
| Метод     | Путь            | Описание                                           | Параметры (GET) / Тело (POST JSON)        | Пример ответа (JSON)                                |
|-----------|-----------------|----------------------------------------------------|-------------------------------------------|-----------------------------------------------------|
| GET / POST| `/api/calculate`| Выполнить арифметическую операцию                    | `num1=X&num2=Y&operation=OP` / `{"num1":X, "num2":Y, "operation":"OP"}` | `{"result": ..., "operand1": ..., ...}`             |

**3.3.6. Сервис "Генератор случайных данных"**
| Метод | Путь                     | Описание                                | Параметры (GET)                      | Пример ответа (JSON)                        |
|-------|--------------------------|-----------------------------------------|--------------------------------------|---------------------------------------------|
| GET   | `/api/random/number`     | Сгенерировать случайное число           | `?min=X&max=Y`                         | `{"random_number": ...}`                    |
| GET   | `/api/random/password`   | Сгенерировать случайный пароль          | `?length=L&use_symbols=true/false`   | `{"password": "...", "length": ..., ...}`  |


### 3.4. Дизайн пользовательского интерфейса (концепция)

При проектировании пользовательского интерфейса основной упор делался на простоту, интуитивную понятность и удобство использования для каждого сервиса.

**Общие принципы дизайна:**

*   **Единообразие:** Все страницы сервисов имеют схожую структуру: заголовок с описанием, блок с документацией API и ниже – интерактивный блок для непосредственной работы с сервисом. Это помогает пользователю быстрее ориентироваться.
*   **Ясность:** Элементы управления (поля ввода, кнопки, выпадающие списки) имеют четкие подписи. Результаты операций и сообщения об ошибках отображаются наглядно.
*   **Минимализм:** Интерфейсы не перегружены лишними элементами, фокус на основной функциональности.
*   **Отзывчивость:** Базовая адаптивность стилей для корректного отображения на экранах разного размера.

**Концепция UI для отдельных сервисов:**

*   **Список Задач:** Форма для добавления новой задачи, список существующих задач с возможностью отметить выполнение и удалить задачу. Текст выполненных задач зачеркивается.
    **(Иллюстрация 4: Вставить здесь эскиз/скриншот UI для "Списка Задач")**
    ![UI Списка Задач](путь/к/скриншоту_todo.png "Интерфейс сервиса Список Задач")

*   **Сокращатель URL:** Одно поле для ввода длинного URL, кнопка "Сократить". Результат (короткий URL и оригинальный) отображается ниже с кнопкой для копирования короткой ссылки.
    **(Иллюстрация 5: Вставить здесь эскиз/скриншот UI для "Сокращателя URL")**
    ![UI Сокращателя URL](путь/к/скриншоту_shortener.png "Интерфейс Сокращателя URL")

*   **Цитаты дня:** Две кнопки ("Случайная цитата", "Найти по ID") и поле для ввода ID. Результат отображается в виде стилизованной цитаты.
    **(Иллюстрация 6: Вставить здесь эскиз/скриншот UI для "Цитат дня")**
    ![UI Цитат дня](путь/к/скриншоту_quotes.png "Интерфейс сервиса Цитаты дня")

*   **Каталог книг/фильмов:** Форма для добавления нового элемента (с динамическим изменением поля "Автор/Режиссер" в зависимости от типа), форма для фильтрации каталога и сеточный вывод карточек элементов каталога.
    **(Иллюстрация 7: Вставить здесь эскиз/скриншот UI для "Каталога")**
    ![UI Каталога](путь/к/скриншоту_catalog.png "Интерфейс Каталога книг и фильмов")

*   **Калькулятор:** Интерфейс, имитирующий классический кнопочный калькулятор, с цифровыми кнопками, кнопками операций, "равно", "очистить", и дисплеем для отображения ввода и результата.
    **(Иллюстрация 8: Это изображение вы мне уже присылали, вставьте его сюда)**
    ![UI Калькулятора](путь/к/вашему_эскизу_калькулятора.png "Дизайн интерфейса Калькулятора")

*   **Генератор случайных данных:** Две секции – для генерации чисел (поля min/max, кнопка) и для генерации паролей (поля длина/спецсимволы, кнопка, поле для вывода пароля с кнопкой копирования).
    **(Иллюстрация 9: Вставить здесь эскиз/скриншот UI для "Генератора")**
    ![UI Генератора данных](путь/к/скриншоту_random.png "Интерфейс Генератора случайных данных")

Целью было создать не только функциональные, но и визуально приятные интерфейсы, с которыми пользователю будет легко и комфортно работать. Детальная реализация стилей описана в соответствующем разделе (`style.css`).

## 4. Пошаговое руководство по созданию "Мультисервисного веб-портала"

Этот раздел представляет собой подробное руководство, которое шаг за шагом проведет вас через процесс создания "Мультисервисного веб-портала" на Python с использованием микрофреймворка Flask. Мы начнем с настройки необходимого окружения и закончим реализацией функциональных сервисов с интерактивными пользовательскими интерфейсами. Руководство ориентировано на тех, кто делает первые шаги в веб-разработке, поэтому мы постараемся объяснять каждый этап максимально доступно.

### 4.1. Подготовка рабочего окружения

Прежде чем приступить к написанию кода, важно правильно подготовить среду разработки. Это обеспечит стабильность работы вашего приложения и упростит управление зависимостями.

#### 4.1.1. Установка Python

Если Python еще не установлен на вашем компьютере, вам необходимо его установить. Наш проект использует Python 3.

1.  **Загрузка:** Перейдите на официальный сайт Python ([python.org](https://python.org/downloads/)) и загрузите последнюю стабильную версию Python 3 для вашей операционной системы (Windows, macOS, Linux).
2.  **Установка:**
    *   **Для Windows:** Запустите загруженный установщик. **Очень важно** на первом экране установки отметить галочку "Add Python to PATH" (или "Add Python X.Y to PATH"). Это позволит вам запускать Python из командной строки из любой директории. Далее следуйте инструкциям установщика (обычно достаточно выбрать "Install Now").
    *   **Для macOS:** Python обычно предустановлен, но это может быть более старая версия (Python 2). Рекомендуется установить свежую версию Python 3 с официального сайта. Также можно использовать менеджер пакетов Homebrew (`brew install python3`).
    *   **Для Linux:** Python 3 часто предустановлен. Проверить можно командой `python3 --version`. Если его нет или версия устарела, воспользуйтесь менеджером пакетов вашего дистрибутива (например, `sudo apt update && sudo apt install python3 python3-pip python3-venv` для Debian/Ubuntu).
3.  **Проверка установки:** Откройте терминал (командную строку, PowerShell) и введите команды:
    ```bash
    python --version 
    # или, если python ссылается на старую версию:
    python3 --version
    pip --version
    # или
    pip3 --version
    ```
    Вы должны увидеть установленные версии Python и pip (менеджер пакетов Python).

![Проверка наличия Python на устройстве](./images/python.png)

#### 4.1.2. Создание виртуального окружения

Виртуальное окружение – это изолированная среда для вашего Python-проекта, которая позволяет управлять зависимостями (библиотеками) конкретного проекта отдельно от других проектов и системных библиотек. Это очень хорошая практика.

1.  **Создайте папку для проекта:** Откройте терминал и перейдите в директорию, где вы хотите разместить свой проект. Затем создайте новую папку и перейдите в нее.
    ```bash
    mkdir multi_service_portal
    cd multi_service_portal
    ```
2.  **Создайте виртуальное окружение:** Внутри папки проекта выполните команду (название `venv` для окружения является общепринятым, но вы можете выбрать другое):
    ```bash
    python -m venv venv
    # или для некоторых систем
    python3 -m venv venv 
    ```
    Эта команда создаст папку `venv` (или как вы ее назвали) внутри вашего проекта, содержащую копию интерпретатора Python и структуру для установки пакетов.

3.  **Активируйте виртуальное окружение:**
    *   **Windows (Command Prompt):**
        ```bash
        venv\Scripts\activate.bat
        ```
    *   **Windows (PowerShell):**
        ```bash
        venv\Scripts\Activate.ps1 
        # Если выполнение скриптов запрещено, может потребоваться команда:
        # Set-ExecutionPolicy Unrestricted -Scope Process 
        # (после активации можно вернуть на место)
        ```
    *   **macOS и Linux (bash/zsh):**
        ```bash
        source venv/bin/activate
        ```
    После успешной активации вы увидите префикс `(venv)` (или название вашего окружения) в начале строки терминала. Это означает, что вы работаете внутри изолированного окружения.

#### 4.1.3. Установка необходимых библиотек (Flask)

Теперь, когда виртуальное окружение активировано, мы можем установить Flask.

1.  **Установка Flask:** В активированном виртуальном окружении выполните команду:
    ```bash
    pip install Flask
    ```
    Эта команда загрузит и установит Flask, а также все его зависимости (например, Werkzeug для WSGI-сервера и Jinja2 для шаблонизации) в ваше виртуальное окружение.

2.  **(Рекомендуется) Создание файла `requirements.txt`:** Чтобы в будущем можно было легко воспроизвести ваше окружение на другом компьютере или при развертывании, создайте файл со списком зависимостей:
    ```bash
    pip freeze > requirements.txt
    ```
    Этот файл теперь будет содержать что-то вроде `Flask==X.Y.Z` и другие установленные пакеты с их версиями. Если кто-то другой захочет запустить ваш проект, он сможет установить все зависимости командой `pip install -r requirements.txt`.

### 4.2. Создание базовой структуры Flask-приложения

Теперь, когда окружение готово, приступим к созданию основы нашего Flask-приложения.

#### 4.2.1. Файл `app.py` – инициализация приложения

Это будет главный файл нашего бэкенда.

1.  **Создайте файл `app.py`** в корневой папке вашего проекта (`multi_service_portal/`).
2.  **Напишите минимальный код для запуска Flask-приложения:**

    ```python
    # app.py

    from flask import Flask

    # Инициализируем экземпляр Flask-приложения.
    # __name__ помогает Flask определить корень приложения для поиска ресурсов.
    app = Flask(__name__)

    # Определяем простой маршрут для главной страницы.
    # Декоратор @app.route связывает URL-путь '/' с функцией home().
    @app.route('/')
    def home():
        return "Привет! Это мой первый Flask-сайт!"

    # Этот блок гарантирует, что сервер разработки Flask будет запущен,
    # только если скрипт app.py выполняется напрямую (а не импортируется как модуль).
    if __name__ == '__main__':
        # app.run() запускает встроенный веб-сервер.
        # debug=True - включает режим отладки (очень полезно при разработке).
        # host='0.0.0.0' - делает сервер доступным по всем сетевым интерфейсам 
        #                  (не только с localhost), удобно для тестирования с других устройств.
        # port=5001 - указывает порт, на котором будет работать сервер.
        app.run(host='0.0.0.0', port=5001, debug=True)
    ```

    **Запустите его:** В терминале, находясь в папке проекта и с активированным виртуальным окружением, выполните `python app.py`. Вы должны увидеть сообщения о запуске сервера и адреса, по которым он доступен (например, `http://127.0.0.1:5001/`). Откройте этот адрес в браузере, и вы увидите "Привет! Это мой первый Flask-сайт!".

#### 4.2.2. Создание папок `static` и `templates`

Flask ожидает, что статические файлы (CSS, JavaScript, изображения) будут находиться в папке `static`, а HTML-шаблоны — в папке `templates`.

1.  В корневой папке вашего проекта (`multi_service_portal/`) **создайте две папки:**
    *   `static`
    *   `templates`
2.  Внутри папки `static` **создайте подпапки:**
    *   `css` (для файлов стилей)
    *   `images` (для изображений)

Теперь ваша структура проекта должна выглядеть примерно так:
/multi_service_portal/
├── app.py
├── static/
│ ├── css/
│ └── images/
├── templates/
└── venv/ # Папка виртуального окружения
└── requirements.txt # (если создали)

**(Иллюстрация 10 (если в 3.2 не было): Можно обновить диаграмму файловой структуры, показав добавленные папки.)**

### 4.3. Разработка базового макета сайта (`layout.html`)

`layout.html` будет служить основным шаблоном, который будут наследовать все остальные страницы сайта. Он определяет общие элементы, такие как шапка, навигация и подвал.

1.  **Создайте файл `layout.html`** внутри папки `templates/`.
2.  **Наполните его базовой HTML-разметкой и блоками Jinja2:**

    ```html
    <!-- templates/layout.html -->
    <!DOCTYPE html>
    <html lang="ru">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- Блок для заголовка страницы, будет переопределен на каждой странице -->
        <title>{% block title %}Мой Мультисервисный Портал{% endblock %} - Название Проекта</title>
        <!-- Подключаем наш основной файл стилей -->
        <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
        <!-- Подключаем иконку сайта (favicon) -->
        <link rel="icon" href="{{ url_for('static', filename='images/home-button.png') }}"> 
    </head>
    <body>
        <header>
            <nav>
                <div class="nav-left">
                    <a href="{{ url_for('home_page') }}" id="home-link">
                        <!-- Поместите сюда свою иконку или создайте заглушку -->
                        <img src="{{ url_for('static', filename='images/home-button.png') }}" alt="Домой" id="home-icon">
                    </a>
                </div>
                <div class="nav-center">
                    <!-- Блок для заголовка в шапке, может совпадать с title или быть уникальным -->
                    <h1>{% block header_title %}Мультисервисный Портал{% endblock %}</h1>
                </div>
                <div class="nav-right">
                    <a href="{{ url_for('list_all_services_page') }}">Сервисы</a>
                    <a href="#footer-contacts">Контакты</a> {# Якорь на подвал #}
                </div>
            </nav>
        </header>
    
        <main>
            <!-- Основной блок контента, будет уникальным для каждой страницы -->
            {% block content %}
            <p>Содержимое страницы будет здесь...</p>
            {% endblock %}
        </main>
    
        <footer id="footer-contacts"> {# Добавлен ID для якоря #}
            <h2>Контакты</h2>
            <p>Telegram: <a href="https://t.me/dontopentheboxx" target="_blank">@dontopentheboxx</a></p>
            <p>GitHub: <a href="https://github.com/a1lock" target="_blank">a1lock</a></p>
            <p>Email: <a href="mailto:a1lockteam@a1l.com">a1lockteam@a1l.com</a></p>
            <p>Телефон: +7 (800) 555-35-35</p>
            <!-- Переменная current_year будет доступна благодаря @app.context_processor -->
            <p>© {{ current_year }} Ailock team corp./a1l. Все права защищены.</p>
        </footer>
    </body>
    </html>
    ```
    *   `{{ url_for('static', filename='...') }}` генерирует правильный путь к статическим файлам.
    *   `{% block ... %}` ... `{% endblock %}` определяют блоки, которые можно будет переопределять в дочерних шаблонах.
    *   Использование `url_for('имя_функции_маршрута')` для ссылок – это лучшая практика во Flask. Убедитесь, что имена функций (`home_page`, `list_all_services_page`) соответствуют тем, что у вас в `app.py`.

**(Иллюстрация 11: Схема макета страницы.)**
*   *Описание для иллюстрации:* "Схематичное представление `layout.html`, показывающее расположение блоков: хедер (с навигацией), основной контент (блок `content`) и футер. Блоки `title` и `header_title` также обозначены."

    ![Схема макета страницы](путь/к/вашей/схеме_макета.png "Общая структура страниц сайта")

### 4.4. Создание главной страницы (`index.html`)

Главная страница будет наследовать `layout.html` и заполнять его блоки своим содержимым.

1.  **Создайте файл `index.html`** в папке `templates/`.
2.  **Наполните его:**

    ```html
    <!-- templates/index.html -->
    {% extends "layout.html" %} {# Наследуем базовый макет #}

    {# Переопределяем блок title для этой страницы #}
    {% block title %}Главная страница{% endblock %}

    {# Переопределяем блок заголовка в шапке (если нужно уникальное значение) #}
    {% block header_title %}Добро пожаловать на наш Портал!{% endblock %}

    {# Переопределяем основной блок контента #}
    {% block content %}
    <section class="hero">
        <h2>Откройте для себя мир удобных онлайн-инструментов!</h2>
        <p>
            Добро пожаловать на наш портал – вашу новую универсальную платформу, 
            где собраны самые разнообразные и полезные онлайн-сервисы. 
            Мы создали это место, чтобы вам больше не приходилось тратить время на 
            поиск нужных инструментов на десятках разных сайтов. Нужно ли вам упорядочить задачи, 
            сократить длинную ссылку, найти вдохновение для нового проекта или 
            просто что-то быстро посчитать – все необходимое уже здесь, под рукой!
        </p>
        <h3>Ключевые возможности нашего портала:</h3> {# Немного изменил заголовок #}
        <ul>
            <li><strong>Всегда что-то найдется:</strong> Наш арсенал включает как простые утилиты для повседневных мелочей, так и более продвинутые инструменты, призванные сделать вашу цифровую жизнь проще и продуктивнее.</li>
            <li><strong>Просто и понятно:</strong> Мы постарались сделать интерфейс интуитивным, а описание каждого API – максимально ясным. Вы сможете легко использовать наши сервисы напрямую или быстро интегрировать их в свои проекты.</li>
            <li><strong>Для всех и каждого:</strong> Если вы разработчик, наши API уже готовы к работе. А если вы просто пользователь, для многих сервисов уже есть или скоро появятся удобные веб-интерфейсы, чтобы вы могли пользоваться ими без лишних сложностей.</li>
            <li><strong>Растем и развиваемся:</strong> Мы не останавливаемся на достигнутом! Наша команда постоянно работает над расширением списка сервисов, добавляя новые полезные и интересные инструменты.</li>
            <li><strong>Открытость и честность:</strong> Многие базовые функции наших сервисов доступны совершенно бесплатно. А если вам понадобится что-то большее, условия расширенного использования всегда будут прозрачными и понятными.</li>
        </ul>
        <p>
            Окунитесь в мир, где технологии работают на вас, делая задачи проще, 
            а идеи – ближе к реализации. Начните свое путешествие по нашим сервисам 
            прямо сейчас и оцените все преимущества сами!
        </p>
        <div class="cta-buttons">
            <a href="{{ url_for('list_all_services_page') }}" class="btn btn-primary">Посмотреть все сервисы</a> {# Изменил текст кнопки #}
            <a href="#footer-contacts" class="btn btn-secondary">Связаться с нами</a>
        </div>
    </section>
    {% endblock %}
    ```
3.  **Обновите `app.py`**, чтобы маршрут `/` рендерил этот шаблон (если еще не сделано в вашей "очеловеченной" версии):

    ```python
    # app.py
    # ... (импорты и инициализация app) ...
    # from flask import render_template (убедитесь, что есть)

    @app.context_processor # Убедитесь, что этот процессор есть
    def inject_global_template_vars():
        return {'current_year': datetime.datetime.now().year}

    @app.route('/')
    def home_page(): # Убедитесь, что имя функции то же, что и в url_for в layout.html
        """Отображает главную (лендинговую) страницу сайта."""
        page_specific_title = 'Главная | Мультисервисный Портал' # Пример более информативного title
        return render_template('index.html', page_title=page_specific_title) # Передаем page_title для layout

    # ... (маршрут для /services и другие) ...
    
    # if __name__ == '__main__': ... (блок запуска)
    ```
    Теперь при запуске и переходе на главную страницу вы должны увидеть отрендеренный `index.html` с общим макетом.

### 4.5. Реализация первого сервиса (на примере "Списка Задач")

Этот подраздел подробно описывает создание одного из сервисов – "Списка Задач". Остальные сервисы будут реализовываться по аналогичной схеме.

#### 4.5.1. Проектирование API для "Списка Задач"

Как было определено на этапе проектирования API (Раздел 3.3.1), нам понадобятся следующие эндпоинты:

*   `POST /api/tasks` - Создание новой задачи.
*   `GET /api/tasks` - Получение всех задач.
*   `GET /api/tasks/<id>` - Получение задачи по ID.
*   `PUT /api/tasks/<id>` - Обновление задачи.
*   `DELETE /api/tasks/<id>` - Удаление задачи.

Данные задачи будут представляться в виде JSON-объектов, например:
`{"id": 1, "text": "Купить продукты", "done": false}`

#### 4.5.2. Реализация API-эндпоинтов в `app.py`

Добавим соответствующий код в наш `app.py`.

1.  **Хранилище данных (временно в памяти):**
    В начале `app.py` (после `app = Flask(__name__)` и конфигураций) добавьте:
    ```python
    # Сервис 1: Список Задач (To-Do List) - Хранилище и счетчик
    tasks_db = [] 
    _next_task_id_counter = 1
    ```

2.  **Код API-эндпоинтов (возьмем из вашего "очеловеченного" `app.py`):**
    ```python
    # app.py
    # ... (импорты, app, context_processor, tasks_db, _next_task_id_counter) ...

    @app.route('/api/tasks', methods=['POST'])
    def tasks_api_create():
        """API: Создает новую задачу."""
        global _next_task_id_counter # Указываем, что будем изменять глобальную переменную
        if not request.is_json:
            return jsonify({"error": "Некорректный формат запроса: ожидается JSON."}), 400
        
        json_data = request.get_json()
        task_description_text = json_data.get('text')

        if not task_description_text or not isinstance(task_description_text, str) or not task_description_text.strip():
            return jsonify({"error": "Поле 'text' для задачи обязательно и не может быть пустым."}), 400
        
        new_task_item = {
            'id': _next_task_id_counter,
            'text': task_description_text.strip(),
            'done': False 
        }
        tasks_db.append(new_task_item)
        _next_task_id_counter += 1
        
        return jsonify({'message': 'Задача успешно создана.', 'task': new_task_item}), 201

    @app.route('/api/tasks', methods=['GET'])
    def tasks_api_get_all():
        """API: Возвращает список всех задач."""
        return jsonify({'count': len(tasks_db),'tasks': tasks_db})

    @app.route('/api/tasks/<int:task_id>', methods=['GET'])
    def tasks_api_get_one(task_id: int):
        """API: Возвращает одну задачу по ее ID."""
        found_task = next((task for task in tasks_db if task['id'] == task_id), None)
        if found_task is None:
            return jsonify({"error": f"Задача с идентификатором {task_id} не найдена."}), 404
        return jsonify({'task': found_task})

    @app.route('/api/tasks/<int:task_id>', methods=['PUT'])
    def tasks_api_update_one(task_id: int):
        """API: Обновляет существующую задачу (текст и/или статус выполнения)."""
        task_to_modify = next((task for task in tasks_db if task['id'] == task_id), None)
        if task_to_modify is None:
            return jsonify({"error": f"Задача с ID {task_id} не найдена и не может быть обновлена."}), 404
        
        if not request.is_json:
            return jsonify({"error": "Тело запроса для обновления должно быть в формате JSON."}), 400
        
        update_data = request.get_json()
        fields_updated_count = 0 # Счетчик фактически обновленных полей

        if 'text' in update_data:
            new_text = update_data['text']
            if isinstance(new_text, str) and new_text.strip(): # Валидация нового текста
                task_to_modify['text'] = new_text.strip()
                fields_updated_count += 1
            # Если text передан, но невалиден, можно вернуть ошибку 400 или просто проигнорировать
        
        if 'done' in update_data:
            new_status = update_data['done']
            if isinstance(new_status, bool): # Валидация статуса
                task_to_modify['done'] = new_status
                fields_updated_count += 1
            # Аналогично, можно вернуть ошибку 400 при невалидном статусе
        
        if fields_updated_count == 0 and update_data: # Если тело запроса не пустое, но валидных полей для обновления нет
             return jsonify({"message": "Данные для обновления не предоставлены или не соответствуют формату.", 'task': task_to_modify}), 400 # Bad Request
            
        return jsonify({'message': f'Задача {task_id} была успешно обновлена.', 'task': task_to_modify})

    @app.route('/api/tasks/<int:task_id>', methods=['DELETE'])
    def tasks_api_delete_one(task_id: int):
        """API: Удаляет задачу по ее ID."""
        global tasks_db 
        
        original_length = len(tasks_db)
        tasks_db = [task for task in tasks_db if task['id'] != task_id]
        
        if len(tasks_db) == original_length: 
            return jsonify({"error": f"Задача с идентификатором {task_id} не найдена для удаления."}), 404
            
        return jsonify({"message": f"Задача {task_id} успешно удалена из списка."}), 200
    ```
    Вы уже можете протестировать эти API-эндпоинты с помощью Postman или `curl`.

#### 4.5.3. Создание HTML-шаблона для страницы сервиса (`service_todo.html`)

Создадим страницу, которая будет отображать как документацию API, так и интерактивный интерфейс.

1.  **Создайте файл `service_todo.html`** в папке `templates/`.
2.  **Скопируйте в него код шаблона `service_todo.html`**, который мы подготовили ранее (с описанием API и интерактивным блоком). Убедитесь, что переменная, через которую передаются данные о сервисе, называется `service_data`, как мы определили в `app.py` для этого маршрута.

    ```python
    # app.py - соответствующий маршрут
    @app.route('/service/todo')
    def service_todo_page():
        service_page_data = { # Данные для страницы
            "name": "Список задач (To-Do List)",
            "intro": "Наш 'Список задач' поможет вам...", # Очеловеченный текст
            "endpoints": [ # Описание эндпоинтов
                {"method": "POST", "path": url_for('tasks_api_create'), ...},
                # ... и остальные эндпоинты ...
            ]
        }
        return render_template('service_todo.html', service_data=service_page_data, page_title=service_page_data["name"])
    ```
    HTML-код для `service_todo.html` я приводил в предыдущих ответах, он уже содержит как секцию с `{% for endpoint in service_data.endpoints %}`, так и секцию `<section class="interactive-todo">` с формами.

#### 4.5.4. Добавление JavaScript для интерактивности

Код JavaScript уже включен в `service_todo.html` (внутри тегов `<script>...</script>`), как мы это делали ранее. Он отвечает за:
*   Загрузку списка задач при открытии страницы.
*   Отправку формы добавления новой задачи на `POST /api/tasks`.
*   Обновление статуса задачи через `PUT /api/tasks/<id>`.
*   Удаление задачи через `DELETE /api/tasks/<id>`.
*   Динамическое обновление списка задач на странице без перезагрузки.

**(Иллюстрация 12: Скриншот работающего интерфейса To-Do листа на странице `/service/todo`)**
*   *Описание для иллюстрации:* "Пример интерактивного интерфейса сервиса 'Список Задач', где пользователь может добавлять, просматривать и управлять задачами непосредственно на веб-странице."

    ![Интерфейс "Списка Задач"](путь/к/вашему/скриншоту_todo_ui.png "Работающий UI сервиса To-Do")

### 4.6. Реализация остальных сервисов (по аналогии)

Процесс реализации остальных пяти сервисов ("Сокращатель URL", "Цитаты дня", "Каталог книг/фильмов", "Калькулятор", "Генератор случайных данных") следует той же логике, что и для "Списка Задач":

1.  **Убедитесь, что API-эндпоинты** для сервиса реализованы в `app.py` и корректно работают (вы уже сделали это в "очеловеченной" версии `app.py`). Проверьте их с помощью Postman.
2.  **Создайте соответствующий HTML-шаблон** в папке `templates/` (например, `service_shortener.html`, `service_quote.html` и т.д.).
3.  **В `app.py` создайте маршрут Flask** для страницы этого сервиса (например, `@app.route('/service/shortener') def service_shortener_page(): ...`). Эта функция должна:
    *   Подготовить словарь `service_page_data` с именем сервиса, его описанием и списком его API-эндпоинтов (с использованием `url_for` для путей).
    *   Рендерить соответствующий HTML-шаблон, передавая в него `service_page_data`.
4.  **В HTML-шаблоне сервиса:**
    *   Он должен наследовать `layout.html`.
    *   Включите секцию для отображения описания API, используя данные из `service_page_data.endpoints` (аналогично `service_todo.html`).
    *   Ниже добавьте HTML-разметку для интерактивного пользовательского интерфейса, специфичного для этого сервиса (формы, кнопки, области для вывода результатов).
    *   Внутри тегов `<script>` напишите JavaScript-код для обеспечения интерактивности:
        *   Получение ссылок на элементы DOM.
        *   Добавление обработчиков событий (например, на отправку формы, клик по кнопке).
        *   Выполнение AJAX-запросов (Fetch API) к соответствующим API-эндпоинтам вашего бэкенда.
        *   Обработка ответов от сервера и динамическое обновление содержимого страницы.
        *   Отображение сообщений об успехе или ошибках.

    **Примеры JavaScript для каждого сервиса вы уже создали в предыдущих итерациях.** Убедитесь, что `apiUrl...` в вашем JavaScript использует `url_for` или корректные относительные пути к вашим API-эндпоинтам.

    **(Иллюстрации 13-17: Для каждого из оставшихся пяти сервисов рекомендуется вставить по одному скриншоту их работающего интерактивного интерфейса, аналогично тому, как это сделано для To-Do листа.)**
    *   Например: "Рис. X. Интерактивный интерфейс сервиса 'Сокращатель URL'".

### 4.7. Стилизация приложения (`style.css`)

Файл `static/css/style.css` содержит все стили, необходимые для придания вашему веб-порталу профессионального и согласованного вида. Мы уже подробно рассмотрели и создали этот файл в предыдущих шагах. Ключевые аспекты стилизации включают:

*   **Общие стили:** Для `body`, `header`, `nav`, `main`, `footer`, типографики, ссылок, кнопок (`.btn`, `.btn-primary`, `.btn-action` и т.д.).
*   **Стили для страниц:** Лендинг (`.hero`), страница со списком сервисов (`.services-grid`, `.service-widget`).
*   **Стили для страниц описания сервисов:** Оформление карточек API-эндпоинтов (`.endpoint-card`, `pre code`).
*   **Специфичные стили для каждого интерактивного блока:**
    *   `.interactive-todo` и его дочерние элементы.
    *   `.interactive-shortener` и его элементы.
    *   `.interactive-quote` и его элементы.
    *   `.interactive-catalog` и его элементы.
    *   `.interactive-calculator-ui` и его элементы (включая `.calculator-container`, `.calculator-display`, `.calc-btn`).
    *   `.interactive-random` и его элементы (`.generator-section`).
*   **Отзывчивость:** Базовые принципы (использование `repeat(auto-fit, ...)` в гридах, `flex-wrap`) помогают сайту адаптироваться под разные размеры экранов, но для идеальной мобильной версии может потребоваться дополнительная работа с `@media` запросами.

Рекомендуется периодически просматривать и рефакторить CSS-код, чтобы он оставался чистым, хорошо организованным и легко поддерживаемым. Использование комментариев для разделения логических блоков стилей также является хорошей практикой.

### 4.8. Запуск и тестирование приложения

1.  **Запуск сервера разработки Flask:**
    *   Убедитесь, что вы находитесь в корневой папке проекта в терминале.
    *   Активируйте ваше виртуальное окружение (например, `source venv/bin/activate` или `venv\Scripts\activate.bat`).
    *   Выполните команду: `python app.py`
    *   Сервер должен запуститься, и вы увидите адреса, по которым доступно приложение (например, `http://127.0.0.1:5001/`).

2.  **Тестирование в браузере:**
    *   Откройте указанный адрес в веб-браузере.
    *   Проверьте навигацию по сайту: главная страница, страница "Сервисы", переход на страницы отдельных сервисов.
    *   На каждой странице сервиса протестируйте всю интерактивную функциональность:
        *   Для "Списка Задач": добавление, отметка, удаление.
        *   Для "Сокращателя URL": ввод URL, получение короткой ссылки, работа редиректа (откройте короткую ссылку), копирование.
        *   Для "Цитат": получение случайной цитаты, поиск по ID.
        *   Для "Каталога": добавление новых элементов, работа фильтров.
        *   Для "Калькулятора": выполнение всех арифметических операций, работа кнопок AC, +/-, %.
        *   Для "Генератора": генерация чисел в разных диапазонах, генерация паролей с разными параметрами, копирование пароля.
    *   Проверьте, как отображаются сообщения об успехе и ошибках.
    *   Проверьте сайт на разных размерах окна браузера, чтобы оценить базовую адаптивность.

3.  **Тестирование API (опционально, но рекомендуется для проверки бэкенда):**
    *   Используйте инструменты, такие как Postman, Insomnia или утилиту командной строки `curl`, чтобы отправлять прямые запросы к вашим API-эндпоинтам (`/api/...`).
    *   Проверьте каждый эндпоинт с корректными и некорректными данными, чтобы убедиться в правильности обработки ошибок и возвращаемых статус-кодов.

Этот раздел руководства должен дать достаточно информации для воспроизведения и понимания процесса создания вашего "Мультисервисного веб-портала".
